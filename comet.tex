\documentclass[5p,authoryear]{elsarticle}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}

\journal{Astronomy and Computing}

\begin{document}

% Standardised display of inline code snippets.
\lstset{language=Python,basicstyle=\small,columns=fullflexible,frame=trBL,showstringspaces=false}

\begin{frontmatter}

\title{Comet: A VOEvent Broker}

% Trying to list here all the people who have directly contributed code or
% testing to TraP development and/or are expected to write text for this
% paper. Then the rest of the TKP in alphabetical order.
\author{John Swinbank}
\ead{j.swinbank@uva.nl}

\address{Astronomical Institute ``Anton Pannekoek'', University of Amsterdam, Postbus 94249, 1090 GE Amsterdam, The Netherlands}

\begin{abstract}

Enemy ships detected in sector 47!

\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)

\end{keyword}

\end{frontmatter}

\section{Introduction}
\label{sec:intro}

The exploration of the astrophysical time domain through timely follow-up
observations of transients offers the potential of many and varied potential
scientific results. However, to achieve these results it is necessary to
overcome a range of technical challenges in terms of identifying and
classifying transients, disseminating notifications of them to the community,
and coordinating follow-up efforts.

Mechanisms for distributing news of transient events already exist: both the
NASA Gamma-ray Coordinates Network\footnote{\url{http://gcn.gsfc.nasa.gov/}}
and The Astronomer's
Telegram\footnote{\url{http://www.astronomerstelegram.org/}} have long and
distinguished track records of enabling transient astronomy. However, the next
generation of large-scale survey telescopes such as Gaia, SKA and LSST promise
hundreds, thousands or even millions of transient detections every day. The
sheer volume of events presents a massive scalability challenge: it is no
longer practical for even large teams of astronomers to consider manually
reading, understanding and responding to these notifcations. Instead,
automation is essential. Furthermore, the diverse nature of these transient
hunting facilities---covering not only electromagnetic gamut from
low-frequency radio to space based X- and $\gamma$-ray monitors, but also
potentially including other types of signal such as gravitational
waves---means that a flexible and adaptable machine-readable mechanism must be
adopted for describing transients.

In an effort to address these challenges, the IVOA has introduced the
`VOEvent'\footnote{\url{http://www.voevent.org/}} \citep{Seaman:2011}
standard. VOEvent provides a standardized, machine- and human-readable way of
describing a wide range of transient astronomical phenomena. An individual
VOEvent describes a particular transient event, providing not only information
about what has been observed and how the observations were made, but also
making it possible for the author to include a scientific motivation for why
this particular event is interesting. Furthermore, a VOEvent may cite other
VOEvents, providing more information about a given transient or, if necessary,
superseding or retracting an earlier message.

VOEvents are published as XML \citep{Bray:2008} XML documents which should be
in compliance with schema \citep{Gau:2012, Peterson:2012} produced by the
IVOA. Working in XML enables VOEvent to make extensive use of other relevant
IVOA standards (?? cite STC, ucd, etc?) and enables convenient processing with
a wide range of standard commercial and open-source tools.

The VOEvent standard defines the structure and content of a VOEvent document,
but it does not describe a mechanism by which the author of a VOEvent may
distribute it to potentially interested recipients. This transport-agnosticism
is intentional: it is intended to provide the maximum possible flexibility, as
individual projects may disseminate events by whatever means best meets their
science goals. However, it is widely recognized that a baseline specification
for a simple transport protocol is of value in terms of providing a common
starting point for building international VOEvent distribution networks
\citep{Williams:2012}. The VOEvent Transport Protocol
\citep[VTP;][]{Allan:2009} is now seeing widespread adoption as such a
baseline.

This manuscript describes Comet, an implementation of all the components
necessary for interacting with the VOEvent Transport Protocol while acting as
a testbed for production-level VTP deployments and for new technologies and
``value-added'' services to assist in addressing the event deluge.  In
\S\ref{sec:vtp} a description of the protocol is provided to set the tool in
context. \S\ref{sec:design} describes how Comet has been designed and built to
meet the protocol specifications. \S\ref{sec:addedvalue} describes how Comet
builds upon VTP to help address future challenges in VOEvent filtering and
selection. \S\ref{sec:perf} considers the performance implications of
deploying VTP in support of next-generation astronomical infrastructure,
considering both the scalability of the protocol to large numbers of events
and to high latency connections. In \S\ref{sec:security} we consider the
security implications of VOEvents, how they can be mitigated at the transport
level, and describe a system being prototyped in Comet.  \S\ref{sec:avail}
describes the terms under which Comet is available and how to download,
install and use it. The results are summarized and conclusions drawn for
future of VOEvent transportation systems in \S\ref{sec:conclusions}.

\section{VOEvent Transport Protocol}
\label{sec:vtp}

\begin{figure*}
  \begin{center}
  \includegraphics[width=0.7\textwidth]{figures/vtp.pdf}
  \end{center}

  \caption{An overview of the passage of a VOEvent through a VTP network. The
  arrows indicate data flow. First the event is sent by an author to a single
  broker. This broker then distributes it to all of its subscribers, which may
  include other brokers, which, in turn, redistribute the event until every
  entity on the network has received a copy.  Adapted from
  \citet{Swinbank:2014}.}

  \label{fig:vtp}
\end{figure*}

VTP provides a simple, minimalist system for distributing VOEvents from one or
more authors to a distribute network of potentially inerested subscribers. It
builds upon the semantics of VOEvent interchange described in the VOEvent
standard \citep{Seaman:2011}, but includes only those entities which directly
interact by means of the network. To wit, VTP defines the following network
roles:

\begin{description}

  \item[Author]{An author is responsible for creating and publishing one or
  more VOEvents.}

  \item[Subscriber]{A subscriber is interested in receiving the VOEvents
  generated by one or more authors.}

  \item[Broker]{The broker receives VOEvents from other network entities
  re-distributes them to one or more subscribers. In addition, the broker may
  perform ``added value'' on behalf of the subcriber, for example by filtering
  the event stream and forwarding only events of interest, or by annotating
  events with additional information.}

\end{description}

Connections between these entities take place over TCP \citep{Cerf:1974}. The
standard defines three types of connection:

\begin{description}

  \item[Author to Broker]{The author makes a TCP connection to the broker and
  transmits a VOEvent packet. On receipt, the broker sends an acknowledgement.
  The connection is then closed.}

  \item[Broker to Subscriber]{The author opens a TCP connection to the broker,
  which remains open indefinitely. The broker and subscriber send periodic
  ``heartbeat'' messages over the conenction to verify that it remains live.
  When the broker receives an event for distribution, it sends it to the
  subscriber over this connection. The subcriber replies with an
  acknowledgement.}

  \item[Broker to Broker]{A broker may subscriber to the output of another
  broker. In doing so, it acts as a subscriber, and the relationship between
  them is as described in ``Broker to Subscriber'', above.}

\end{description}

Note that the the broker-to-subscriber connection remains open at all times,
even when a subscriber has recently received an event. The standard mandates
that the subscriber must always be prepared to receive more events, even while
a previous event is still being processed: otherwise, a backlog of events
waiting to be sent to a particular subscriber could build up and overload the
broker.

By causing brokers to subscriber to the output from other brokers, we can
build extended networks of mutually-interconnected brokers. An author need
only publish to one broker, and ultimately their event id distributed to all
entities on the network. This is not only efficient, it is also robust: the
failure of any given entity can only cause local disruption to the
distribution network. The topology of such a network, and the path a VOEvent
packet might take across it, is shown in Fig. \ref{fig:vtp}.

Building a mesh of interconnected brokers in this fashion has significant
advantages, but it also introduces complexity. Specifically, brokers must
guard against events ``looping'' on the network, as two or more brokers
repeatedly exchange the same event. Brokers are therefore required not to
process a given event more than once, however many times it is received.

In addition to passing VOEvent XML documents, VTP defines a ``Transport''
document type. Transport documents are used for the heartbeat messages between
brokers and subscribers and for sending acknowledgement of event receipt. The
documents are kept intentionally short, providing simply a timestamp, an
indication of the originator, and---in the case of a acknowledgement---the
identity of the event being acknowledged.

VTP makes limited provision for securing access to the network: that is, for
limiting the authors and subscribers which may connect to a given broker. The
simplest, albeit least flexible, approach is for the broker to maintain a
``whitelist'' of the IP addresses of entities which are authorized to connect,
and simply drop connections coming from elsewhere. Such a system is convenient
and easy to implement for small networks, but can rapidly become unwieldy as
the list of authorized users grows or as those users need to connect from
multiple addresses. An alternative is therefore suggested in the standard
based on cryptographically signed transport messages, which enable an entity
to securely demonstrate its identity on connection. The means by which these
signatures may be applied is not specified in the VTP standard, which rather
refers to the systems proposed by \citet{Denny:2008}, \citet{Allen:2008} and
\citet{Rixon:2005}. The application of cryptographic signatures to XML
documents is a potentially complex topic, and one to which we return in
\S\ref{sec:security}.

\section{The Design and Implementation of Comet}
\label{sec:design}

Comet\footnote{\url{http://comet.transientskp.org/}} is a freely available,
open source implementation of VTP. It is capable of acting any or all of the
roles within a VTP network: it can receive events from remote brokers (the
subscriber role), receive events from authors and distribute them to
subscribers (the broker role) and it provides a tool which can publish a
VOEvent to a remote broker (the author role). Comet has the twin aims of
acting both as a production-ready event distribution system, which projects
can immediately start using to service their science goals, and as a
convenient system for exploring the characteristics of VTP and exploring and
prototyping future extensions to the protocol. The first aim has already been
met: see, for example, \citet{Staley:2013}. Early results from the second aim
are described in the subsequeny sections of this manuscript.

\subsection{Twisted Python and event-driven programming}
\label{sec:design:twisted}

\begin{lstlisting}[float,caption={An example of an event-driven Twisted protocol, based on Comet's VOEventReceiver.},label=lst:event,mathescape]
class VOEventReceiver(Protocol):
  TIMEOUT = 20

  def connectionMade(self):
    setTimeout(self.TIMEOUT)

  def connectionLost(self):
    setTimeout(None)
    close_connection()

  def timeoutConnection(self):
    log.msg($\texttt{"}$Connection timed out$\texttt{"}$)

  def stringReceived(self, data):
    incoming_message = parse(data)
    if is_valid(incoming_message) and \
       incoming_message.get($\texttt{"}$role$\texttt{"}$) in VOEVENT_ROLES:
        log.info($\texttt{"}$Good message received$\texttt{"}$)
        return_acknowledgement(incoming_message)
        process_event(incoming_message)
    else:
        log.warning($\texttt{"}$Bad message received$\texttt{"}$)
    close_connection()
\end{lstlisting}

Comet is implemented in Python, and is built atop the Twisted networking
engine\footnote{\url{https://twistedmatrix.com/}}. Twisted enables an
\textit{event-driven} and \textit{asynchronous} style of development which is
extensively used throughout Comet and is fundamental to understanding its
implementation.

Conventionally, we thing of programs as being executed in order: the system
executes the instructions described by the first statement, followed by the
second statement, and so on until the process is complete. Of course,
spreading a process across multiple threads of execution makes the precise
ordering of statements nondeterministic \citep[and, indeed, introduces a whole
new level of complexity in the process;][]{Lee:2006}, but the fundamental
point remains: the aim is to execute the program as rapidly and efficiently as
possible and then exit.

It is obvious that this model does not map well to network based applications.
Consider the ``subscriber'' role in a VOEvent network: it is not rushing to
finish some particular task and then terminate, but rather to continue
listening to the network indefinitely for the arrival of VOEvents, and to
take appropriate action when an event is received. Event-driven programming is
the generalization of this concept: rather than a list of instructions to be
executed sequentially, we define the actions that should be taken in response
to possible events. Twisted then provides an ``event loop'' which waits for
events and calls the appropriate actions when they occur.

When talking to the network, Twisted provides the \textit{Protocol} as an
abstraction for managing events. A protocol defines the interaction that a
particular component of the system has with the network. For example,
Listing \ref{lst:event} shows a simplified version of the protocol for Comet's
VOEventReceiver. This is the part of the broker which listens to the network
for submissions from authors. Four separate events are handled by this
protocol:

\begin{itemize}

\item{When a new connection is initiated by an author, the broker sets a
timer on the connection. If no traffic is received, the timer will eventually
reach zero and the connection will be timed-out.}

\item{When a connection is lost, the timeout is aborted.}

\item{When a connection times out, close it.}

\item{When a string is received over the connection, parse it and see if it
can be recognized as a valid VOEvent. If so, return an acknowledgement and
process the newly received event (for example by re-distributing it to
subscribers). If not, log a warning message. Finally, shut down the
connection.}

\end{itemize}

Similar, although often more complex, protocols are defined for all of the
other roles in the system: an author connecting to a broker
(``VOEventSender''), a broker to a subscriber (``VOEventBroadcaster''), and an
subscriber to a broker (``VOEventSubscriber'').

Event-driven programming provides a convenient abstraction for responding to
network events as described. However, it does not address issues regarding
concurrency. As described in \S\ref{sec:vtp}, VTP requires that, even
immediately after receiving an event, subscribers must be ready to accept
another event: there can be no delay while the event is ingested. Contrast
this with the model described above and outlined in Listing \ref{lst:event}:
here, when an event is received, we call \lstinline$parse()$,
\lstinline$is_valid()$, \lstinline$return_acknowledgement()$ and
\lstinline$process_event()$ in turn. None of these operations are
instantaneous: while they are ongoing, our event loop is blocked, and new
events cannot be received. We are thus in violation of the VTP standard.

Twisted addresses this problem through the use of \textit{Deferred}s. A
deferred is effectively a promise that processing is underway and that results
will be available in future. We can then queue up other processing tasks (or
``callbacks'') that will be executed when the result of the deferred is
available. For example, we could define a version of
\lstinline$parse()$---call it \lstinline$deferred_parse()$---that, rather than
returning an object representing a parsed version of the VOEvent document,
returns a promise to eventually parse the documument in the future and then
make it available for further processing. We can then queue up our other
functions to run only when parsing is complete. For example, see Listing
\ref{lst:deferred}, in which we queue up a number of callbacks to be run when
parsing is complete and also add an ``errback'' which handles logging a
message if any of the callbacks fail to run successfully.

\begin{lstlisting}[float,caption={A version of \lstinline$VOEventReceiver.stringReceived()$ based on deferred processing.},label=lst:deferred,mathescape]
def stringReceived(self, data):
  d = deferred_parse(data)
  d.addCallback(is_valid)
  d.addCallback(check_role)
  d.addCallback(return_acknowledgement)
  d.addCallback(process_event)
  d.addErrback(log_failure)
  d.addCallback(close_connection)
\end{lstlisting}

Finally, we must consider the implementation of \lstinline$deferred_parse()$.
Simply returning a deferred from a function does not prevent it from blocking.
Instead, we create a dedicated thread which is devoted to parsing the data,
and have it run concurrently with the rest of the application. When that
thread completes, the deferred fires with its result. Conveniently, Twisted
makes it easy to apply this pattern to a blocking function such as our
\lstinline$parse()$: see Listing \ref{lst:deferToThread}.

\begin{lstlisting}[float,caption={The implementation of the non-blocking \lstinline$deferred_parse()$ function.},label=lst:deferToThread,mathescape]
from twisted.internet.threads import deferToThread

def deferred_parse(data):
    return deferToThread(parse, data)
\end{lstlisting}

Although the examples presented in this section are only intended to be
illustrative, they demonstrate the concepts of asynchronous, event-driven
programming upon which Comet is built and are fundamental to understanding its
operation.

\subsection{Comet architecture}

Protocols and brokers and comet-sendvo.



\subsection{Security and whitelisting}
\label{sec:design:security}

\subsection{Plugins: acting on events received}
\label{sec:design:plugin}



\section{Added Value Services}
\label{sec:addedvalue}

\subsection{XPath-Based Filtering}
\label{sec:addedvalue:xpath}

\section{Performance}
\label{sec:perf}

\subsection{Total Throughput}
\label{sec:perf:total}

\subsection{High-Latency Connections}
\label{sec:perf:latency}

\section{Security}
\label{sec:security}

\section{Availability}
\label{sec:avail}

\section{Conclusions}
\label{sec:conclusions}

\section{Acknowledgements}
\label{sec:ack}

The author is grateful to Bob Denny and Alasdair Allan for many useful
discussions on the design and implementation of the VOEvent Transport
Protocol. I also thank Roy Williams and Tim Staley for their feedback on the
design and capabilities of Comet. This project was funded by European Research
Council Advanced Grant XXXXXX `AARTFAAC'.

\section*{References}

\bibliographystyle{elsarticle-harv}
\bibliography{comet}

\end{document}
